{"relation": [["Date", "?", "2011/08/11"], ["Author", "Denise Smith", "Blaise Doughan"], ["Version Description & Notes", "?", "?"]], "pageTitle": "EclipseLink/DesignDocs/350483 - Eclipsepedia", "title": "", "url": "http://wiki.eclipse.org/index.php?title=EclipseLink/DesignDocs/350483&oldid=304501", "hasHeader": true, "headerPosition": "FIRST_ROW", "tableType": "RELATION", "tableNum": 0, "s3Link": "common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042988458.74/warc/CC-MAIN-20150728002308-00341-ip-10-236-191-2.ec2.internal.warc.gz", "recordEndOffset": 260492239, "recordOffset": 260468290, "tableOrientation": "HORIZONTAL", "TableContextTimeStampAfterTable": "{58220=Bug 351588 By default namespaces/prefixes will be ignored during marshal and unmarshal operations. This default behavior is a problem if there are multiple mappings with the same local name in different namespaces as there would be no way to distinguish between those mappings. Users will be able to provide a Map of namespaces to customize the behavior. In JAXB users can set a JAXBMarshaller.NAMESPACE_PREFIX_MAPPER. If a NAMESPACE_PREFIX_MAPPER is set and the media type is application/json namespaces will be written out. If a NAMESPACE_PREFIX_MAPPER is not set and the media type is application/json then namespaces will not be written. To provide different behavior per media type separate jaxbmarshallers can be created. When the mediatype is application/xml then this property is only used during marshal operations. When the mediatype is application/json the NAMESPACE_PREFIX_MAPPER will also be used during unmarshal operations., 61861=Bug 351587 When marshaling if the getMarshalNullRepresentation setting on nullpolicy is ABSENT_NODE we don't write that pair to JSON. If the getMarshalNullRepresentation is NIL we should write \"null\" If the getMarshalNullRepresentation is EMPTY_NODE we should write \"null\", 92777=Copyright \u00a9 2014 The Eclipse Foundation. All Rights Reserved.}", "textBeforeTable": "Document History ER 350483 Design Specification: Object-to-JSON Binding Layer 1.16 Completed 1.15 Backlog 1.14 Future Considerations 1.13 Decisions 1.12 Open Issues 1.11 Documentation 1.10 Config files 1.9 GUI 1.8.1 MediaType - New Enum 1.8 API 1.7 Testing 1.6.2.9 XSI type attribute 1.6.2.8 XmlValue 1.6.2.7 Null support 1.6.2.6 Inheritance 1.6.2.5 Namespaces 1.6.2.4 Collections 1.6.2.3 Attributes 1.6.2.2 JSON Data Types Bug 351119 1.6.2.1 No \"Root Element\" Support 1.6.2 Low Level Design 1.6.1 High Level Design 1.6 Design / Functionality 1.5.2 MOXy Annotations 1.5.1 JAXB Annotations 1.5 Design Constraints 1.4 Requirements", "textAfterTable": "Project overview This feature will add support for converting objects to/from JSON. This is desirable when creating RESTful services as JAX-RS services often accept both XML (application/xml) and JSON (application/json) messages. Goals: Offer the same flexibility as our object-to-XML mappings Where services offer both XML and JSON messages, support both with one set of mappings Not require additional compile time dependencies over the JAXB APIs Be easy to use with JAX-RS (i.e. MessageBodyReader and MessageBodyWriter) Concepts See http://www.json.org/ for more JSON reference Requirements 1 - Same Flexibility as Our Object-to-XML Mapping The new JSON binding will be compatible with all existing MOXy extensions. This includes: External bindings file Dynamic JAXB Extensible models 2 - Where Services Offer Both XML and JSON Messages, Support Both with one set of mappings If the XML representation is: <foo xmlns=\"urn:examle\" id=\"123\"> <bar>Hello World</bar> </foo> And the JSON representation is: {\"foo\" : { \"id\" : 123, \"bar\u00a0: \"Hello World\" }} The goal is to have this supported by one object model:", "hasKeyColumn": true, "keyColumnIndex": 1, "headerRowIndex": 0}